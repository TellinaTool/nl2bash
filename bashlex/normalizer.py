#!/usr/bin/env python
# -*- coding: UTF-8 -*-

"""
This file augments the AST generated by bashlex with single-command structure.
It also performs some normalization on the command arguments.
"""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import copy
import os
import re
import sys
if sys.version_info > (3, 0):
    from six.moves import xrange

# bashlex stuff
from bashlex import bash, bast, errors, tokenizer, bparser
from bashlex.nast import *
from grammar.lookup import ManPageLookUp
from nlp_tools import constants

_H_NO_EXPAND = "__SP__H_NO_EXPAND"
_V_NO_EXPAND = "__SP__V_NO_EXPAND"

man_lookup = ManPageLookUp([os.path.join(
    os.path.dirname(__file__), "..", "grammar", "primitive_cmds_grammar.json")])

def cmd_arg_type_check(word, arg_status):
    if not arg_status:
        return 'Unknown'
    arg_types = []
    for i in xrange(len(arg_status["non-optional"])):
        arg_type, is_list, filled = arg_status["non-optional"][i]
        if not is_list and filled:
            continue
        arg_types.append(arg_type)
    for i in xrange(len(arg_status["optional"])):
        arg_type, is_list, filled = arg_status["optional"][i]
        if not is_list and filled:
            continue
        arg_types.append(arg_type)

    assert(len(arg_types) > 0)
    arg_type = type_check(word, arg_types)

    for i in xrange(len(arg_status["non-optional"])):
        if arg_status["non-optional"][i][0] == arg_type:
            arg_status["non-optional"][i][2] = True
    for i in xrange(len(arg_status["optional"])):
        if arg_status["optional"][i][0] == arg_type:
            arg_status["optional"][i][2] = True

    return arg_type

def type_check(word, possible_types):
    """Heuristically determine argument types."""
    if word in ["+", ";", "{}"]:
        return "ReservedWord"
    if word.isdigit() and "Number" in possible_types:
        return "Number"
    if any(c.isdigit() for c in word):
        if word[-1] in ["k", "M", "G", "T", "P"] and "Size" in possible_types:
            return "Size"
        if word[-1] in ["s", "m", "h", "d", "w"] and "Time" in possible_types:
            return "Time"
    if "Permission" in possible_types:
        if any(c.isdigit() for c in word) or '=' in word:
            return "Permission"
    return possible_types[0]

def is_unary_logic_op(node, parent):
    if node.word == "!":
        return parent and parent.is_command("find")
    return node.word in right_associate_unary_logic_operators \
           or node.word in left_associate_unary_logic_operators

def is_binary_logic_op(node, parent):
    if node.word == '-o':
        if parent and parent.is_command("find"):
            node.word = "-or"
            return True
        else:
            return False
    if node.word == '-a':
        if parent and parent.is_command("find"):
            node.word = "-and"
            return True
        else:
            return False
    if node.word == ',':
        if parent and parent.is_command("find"):
            node.word = "-and"
            return True
        else:
            return False
    return node.word in binary_logic_operators

def correct_errors_and_normalize(cmd):
    # special normalization for certain commands
    ## remove all "sudo"'s
    cmd = cmd.replace("sudo", "")

    ## normalize utilities called with full path
    cmd = cmd.replace("/usr/bin/find", "find")
    cmd = cmd.replace("/bin/find", "find")
    cmd = cmd.replace("/usr/bin/grep", "grep")
    cmd = cmd.replace("/bin/rm", "rm")
    cmd = cmd.replace("/bin/mv", "mv")
    
    ## correct common typos
    cmd = cmd.replace("'{}'", "{}")
    cmd = cmd.replace("\"{}\"", "{}")
    cmd = cmd.replace("-i{}", "-I {}")
    cmd = cmd.replace("-i%", "-I %")
    cmd = cmd.replace("-I{}", "-I {}")
    cmd = cmd.replace(" [] ", " {} ")
    cmd = cmd.replace("-L.", "-L")
    cmd = cmd.replace("-mitime", "-mtime")
    cmd = cmd.replace("-dev", "-xdev")
    cmd = cmd.replace("-regex-type", "-regextype")
    cmd = cmd.replace(" ( ", " \\( ")
    cmd = cmd.replace(" ) ", " \\) ")
    cmd = cmd.replace("-\\(", "\\(")
    cmd = cmd.replace("-\\)", "\\)")
    cmd = cmd.replace("\"\\)", " \\)")
    cmd = cmd.replace("\\(-", "\\( -")
    cmd = cmd.replace("e\\)", "e \\)")
    cmd = cmd.replace("-\\!", "!")
    try:
        cmd = cmd.replace("— ", "-")
        cmd = cmd.replace("–", "-")
        cmd = cmd.replace("—", "-")
        cmd = cmd.replace("“", '"')
        cmd = cmd.replace("”", '"')
        cmd = cmd.replace("-\xd0\xbe", "-o")
        cmd = cmd.replace("\xe2\x80\x93 ", "-")
        cmd = cmd.replace('‘', '\'')
        cmd = cmd.replace('’', '\'')
    except UnicodeDecodeError:
        cmd = cmd.replace("— ".decode('utf-8'), "-")
        cmd = cmd.replace("–".decode('utf-8'), "-")
        cmd = cmd.replace("—".decode('utf-8'), "-")
        cmd = cmd.replace("“".decode('utf-8'), '"')
        cmd = cmd.replace("”".decode('utf-8'), '"')
        cmd = cmd.replace("\xd0\xbe".decode('utf-8'), "o")
        cmd = cmd.replace("\xe2\x80\x93 ".decode('utf-8') , "-")
        cmd = cmd.replace('‘'.decode('utf-8'), '\'')
        cmd = cmd.replace('’'.decode('utf-8'), '\'')

    # more typo fixes
    cmd = re.sub("-prin($| )", '-print', cmd)
    cmd = cmd.replace("/bin/echo", "echo")
    cmd = cmd.replace(" exec sed ", " -exec sed ")
    cmd = cmd.replace(" xargs -iname ", " xargs ")
    cmd = cmd.replace(" -chour +1 ", " -cmin 60 ")
    cmd = cmd.replace(" -target-directory ", " --target-directory=")
    cmd = cmd.replace("- perm", "-perm")
    cmd = cmd.replace(" perm", " -perm")
    cmd = cmd.replace("'-rd\\n' ", '')

    ## remove shell character
    if cmd.startswith("$ "):
        cmd = re.sub("^\$ ", '', cmd)
    if cmd.startswith("# "):
        cmd = re.sub("^\# ", '', cmd)
    if cmd.startswith("$find "):
        cmd = re.sub("^\$find ", "find ", cmd)
    if cmd.startswith("#find "):
        cmd = re.sub("^\#find ", "find ", cmd)

    ## the first argument of "tar" is always interpreted as an option
    tar_fix = re.compile(' tar \w')
    if cmd.startswith('tar'):
        cmd = ' ' + cmd
    for w in re.findall(tar_fix, cmd):
        cmd = cmd.replace(w, w.replace(' tar ', ' tar -'))
    cmd = cmd.strip()
    return cmd

def attach_to_tree(node, parent):
    node.parent = parent
    node.lsb = parent.get_right_child()
    parent.add_child(node)
    if node.lsb:
        node.lsb.rsb = node

def detach_from_tree(node, parent):
    if not parent:
        return
    parent.remove_child(node)
    node.parent = None
    if node.lsb:
        node.lsb.rsb = node.rsb
    if node.rsb:
        node.rsb.lsb = node.lsb
    node.rsb = None
    node.lsb = None

def normalize_ast(cmd, recover_quotes=True, verbose=False):
    """
    Convert the bashlex parse tree of a command into the normalized form.

    :param cmd: bash command to parse
    :param recover_quotes: if set, retain quotation marks in the command
    :param verbose: if set, print error message.
    :return normalized_tree
    """
    cmd = cmd.replace('\n', ' ').strip()
    cmd = correct_errors_and_normalize(cmd)
    if not cmd:
        return None

    def normalize_word(node, recover_quotes):
        w = recover_quotation(node) if recover_quotes else node.word
        return w

    def with_quotation(node):
        return cmd[node.pos[0]] in ['"', '\''] \
            or cmd[node.pos[1]-1] in ['"', '\'']

    def recover_quotation(node):
        if with_quotation(node):
            return cmd[node.pos[0] : node.pos[1]]
        else:
            return node.word

    def normalize_argument(node, current, arg_type):
        value = normalize_word(node, recover_quotes)
        if value in ["+", ";", "{}"]:
            arg_type = "ReservedWord"
        norm_node = ArgumentNode(value=value, arg_type=arg_type)
        attach_to_tree(norm_node, current)
        return norm_node

    def normalize_flag(node, current):
        if '=' in node.word:
            value, arg_value = node.word.rsplit('=', 1)
            norm_node = FlagNode(value=value)
            arg_node = ArgumentNode(value=arg_value,
                arg_type=man_lookup.get_flag_arg_type(current.value, value,
                                                      default_type='Unknown'))
            attach_to_tree(norm_node, current)
            attach_to_tree(arg_node, norm_node)
        else:
            # value = normalize_word(node, recover_quotes)
            value = node.word
            norm_node = FlagNode(value=value)
            attach_to_tree(norm_node, current)
        return norm_node

    def normalize_utility(node, current):
        value = node.word
        norm_node = UtilityNode(value=value)
        attach_to_tree(norm_node, current)
        return norm_node

    def normalize_command(node, current):
        arg_status = None                       # determine argument types
        utilities = []
        unary_logic_ops = []
        binary_logic_ops = []
        unprocessed_unary_logic_ops = []
        unprocessed_binary_logic_ops = []

        def expecting(a_t):
            if not arg_status:
                return None
            for arg_type, is_list, filled in arg_status["non-optional"]:
                if not is_list and filled:
                    continue
                if arg_type == a_t:
                    return True
            for arg_type, is_list, filled in arg_status["optional"]:
                if not is_list and filled:
                    continue
                if arg_type == a_t:
                    return True
            return False

        def organize_buffer(lparenth, rparenth):
            node = lparenth.rsb
            while node != rparenth:
                # if node.kind == "unarylogicop":
                #     adjust_unary_operators(node)
                node = node.rsb
            node = lparenth.rsb
            while node != rparenth:
                # if node.kind == "binarylogicop":
                #     adjust_binary_operators(node)
                node = node.rsb
            node = lparenth.rsb
            if node.rsb == rparenth:
                return lparenth.rsb
            else:
                norm_node = BracketNode()
                while node != rparenth:
                    attach_to_tree(node, norm_node)
                    node = node.rsb
                return norm_node

        def adjust_unary_operators(node):
            if node.associate == UnaryLogicOpNode.RIGHT:
                # change right sibling to child
                rsb = node.rsb
                if not rsb:
                    print("Warning: unary logic operator without a right "
                          "sibling.")
                    return
                if rsb.value == "(":
                    unprocessed_unary_logic_ops.append(node)
                    return
                if rsb.value == ")":
                    # TODO: this corner case is not handled very well
                    node.associate = UnaryLogicOpNode.LEFT
                    unprocessed_unary_logic_ops.append(node)
                    return
                make_sibling(node, rsb.rsb)
                node.parent.remove_child(rsb)
                rsb.lsb = None
                rsb.rsb = None
                node.add_child(rsb)
            elif node.associate == UnaryLogicOpNode.LEFT:
                # change left sibling to child
                lsb = node.lsb
                if not lsb:
                    print("Warning: unary logic operator without a left "
                          "sibling.")
                    print(node.parent)
                    return
                if lsb.value == ")":
                    unprocessed_unary_logic_ops.append(node)
                    return
                if (lsb.kind == "binarylogicop" and lsb.get_num_of_children() < 2) \
                        or lsb.value == "(":
                    # TODO: this corner case is not handled very well
                    # it is often triggered by the bizarre usage of -prune
                    return
                make_sibling(lsb.lsb, node)
                node.parent.remove_child(lsb)
                lsb.lsb = None
                lsb.rsb = None
                node.add_child(lsb)
            else:
                raise AttributeError("Cannot decide unary operator "
                                     "assocation: {}".format(node.symbok))

            # resolve single child of binary operators left as the result of
            # parentheses processing
            if node.parent.kind == "bracket" and node.parent.get_num_of_children() == 1:
                node.grandparent.replace_child(node.parent, node)

        def adjust_binary_operators(node):
            # change right sibling to Child
            # change left sibling to child
            rsb = node.rsb
            lsb = node.lsb

            if not rsb or not lsb:
                raise AttributeError("Error: binary logic operator must have "
                                     "both left and right siblings.")

            if rsb.value == "(" or lsb.value == ")":
                unprocessed_binary_logic_ops.append(node)
                # sibling is parenthese
                return

            assert(rsb.value != ")")
            assert(lsb.value != "(")

            make_sibling(node, rsb.rsb)
            make_sibling(lsb.lsb, node)
            node.parent.remove_child(rsb)
            node.parent.remove_child(lsb)
            rsb.rsb = None
            lsb.lsb = None

            if lsb.kind == "binarylogicop" and lsb.value == node.value:
                for lsbc in lsb.children:
                    make_parent_child(node, lsbc)
                make_parent_child(node, rsb)
                lsbcr = lsb.get_right_child()
                make_sibling(lsbcr, rsb)
            else:
                make_parent_child(node, lsb)
                make_parent_child(node, rsb)
                make_sibling(lsb, rsb)

            # resolve single child of binary operators left as the result of
            # parentheses processing
            if node.parent.kind == "binarylogicop" \
                    and node.parent.value == "-and":
                if node.parent.get_num_of_children() == 1:
                    node.grandparent.replace_child(node.parent, node)

        def attach_flag(node, attach_point_info):
            attach_point = attach_point_info[0]

            if node.word.startswith("--") \
                or is_unary_logic_op(node, attach_point) \
                or node.word in binary_logic_operators \
                or attach_point.value == "find" \
                or len(node.word) <= 1:
                normalize_flag(node, attach_point)
            else:
                # split flags
                assert(node.word.startswith('-'))
                options = node.word[1:]
                if len(options) == 1 and not options.isdigit():
                    normalize_flag(node, attach_point)
                else:
                    if options[-1].isdigit() and (
                      (attach_point.value == "head" and options.isdigit()) or
                      (attach_point.value == "tail" and options.isdigit()) or
                      (attach_point.value in bash.float_arguments and
                           (options[0] in bash.float_arguments[attach_point.value]))):
                        # flag contains a floading argument
                        str = options + " reformed to: "
                        m = re.match('[a-zA-Z]', options)
                        value = m.group(0) if m else ''
                        m = re.search('\d+$', options)
                        arg_value = m.group(0) if m else ''
                        if attach_point.value in ['head', 'tail'] and \
                                not value:
                            value = 'n'
                        new_option = '-' + value + '=' + arg_value
                        new_node = copy.deepcopy(node)
                        new_node.word = new_option
                        normalize_flag(new_node, attach_point)
                        str += new_option
                    else:
                        str = options + " splitted into: "
                        for i in xrange(len(options)):
                            option = options[i]
                            new_node = copy.deepcopy(node)
                            new_node.word = '-' + option
                            new_node.pos = (node.pos[0] + i + 1,
                                            node.pos[1] + i + 2)
                            normalize_flag(new_node, attach_point)
                            str += new_node.word + ' '
                    if verbose:
                        print(str)

            head_cmd = attach_point.utility.value
            flag = node.word
            arg_type = man_lookup.get_flag_arg_type(head_cmd, flag)
            if arg_type:
                # flag is expecting an argument
                attach_point = attach_point.get_right_child()
                return (attach_point, ["argument"], [arg_type])
            else:
                # flag does not take arguments
                return attach_point_info

        def look_above(attach_point):
            head_cmd = attach_point.utility
            return (head_cmd, ["flags", "arguments"], None)

        # Attach point format: (pointer_to_the_attach_point,
        #                       ast_node_type, arg_type)
        attach_point_info = (current, ["utility"], [])

        ind = 0
        while ind < len(node.parts):
            attach_point = attach_point_info[0]
            possible_node_kinds = attach_point_info[1]
            possible_arg_types = attach_point_info[2]

            child = node.parts[ind]
            if child.kind == 'word':
                # prioritize processing of logic operators
                if is_unary_logic_op(child, attach_point):
                    norm_node = UnaryLogicOpNode(child.word)
                    attach_to_tree(norm_node, attach_point)
                    unary_logic_ops.append(norm_node)
                elif is_binary_logic_op(child, attach_point):
                    norm_node = BinaryLogicOpNode(child.word)
                    attach_to_tree(norm_node, attach_point)
                    binary_logic_ops.append(norm_node)
                else:
                    if child.word == "--" and not attach_point.is_command("awk"):
                        attach_point_info = (attach_point_info[0], ["argument"],
                                             attach_point_info[2])
                        ind += 1
                        continue

                    if len(possible_node_kinds) == 1:
                        # no ast_node_kind ambiguation
                        node_kind = possible_node_kinds[0]
                        if node_kind == "utility":
                            norm_node = normalize_utility(child,
                                                              attach_point)
                            utilities.append(norm_node)
                            head_cmd = norm_node.value
                            arg_status = copy.deepcopy(man_lookup.get_arg_types(head_cmd))
                            attach_point_info = \
                                (norm_node, ["flag", "argument"], None)
                        elif node_kind == "argument":
                            if possible_arg_types and "Prog" in possible_arg_types:
                                # embedded command leaded by
                                # ["-exec", "-execdir", "-ok", "-okdir"]
                                new_command_node = bast.node(kind="command",
                                                             word="",
                                                             parts=[],
                                                             pos=(-1,-1))
                                new_command_node.parts = []
                                subcommand_added = False
                                for j in xrange(ind, len(node.parts)):
                                    if hasattr(node.parts[j], 'word') \
                                        and (node.parts[j].word == ";" \
                                        or node.parts[j].word == "+"):
                                        normalize_command(new_command_node,
                                                          attach_point)
                                        attach_point.value += \
                                            '::' + node.parts[j].word
                                        subcommand_added = True
                                        break
                                    else:
                                        new_command_node.parts.\
                                            append(node.parts[j])
                                if not subcommand_added:
                                    print("Warning: -exec missing ending ';'")
                                    normalize_command(new_command_node,
                                                      attach_point)
                                    attach_point.value += '::' + ";"
                                ind = j
                            else:
                                if possible_arg_types:
                                    arg_type = list(possible_arg_types)[0]
                                else:
                                    # "--" encountered
                                    arg_type = cmd_arg_type_check(
                                        child, arg_status)
                                # recurse to main normalization to handle
                                # argument with deep structures
                                normalize(child, attach_point, "argument",
                                          arg_type)
                            attach_point_info = look_above(attach_point)
                    else:
                        # need to decide ast_node_kind
                        if child.word.startswith("-") and \
                            not ((attach_point.value in ["chmod"]
                                and re.match(constants._NUMERICAL_PERMISSION_RE,
                                    child.word))):
                            # child is a flag
                            attach_point_info = \
                                attach_flag(child, attach_point_info)
                        else:
                            # child is an argument
                            if expecting("Prog"):
                                # embedded command leaded by
                                # ["sh", "csh", "ksh", "tcsh",
                                #  "zsh", "bash", "exec", "xargs"]
                                new_command_node = bast.node(kind="command",
                                                             word="",
                                                             parts=[],
                                                             pos=(-1,-1))
                                new_command_node.parts = []
                                for j in xrange(ind, len(node.parts)):
                                    new_command_node.parts.append(node.parts[j])
                                normalize_command(new_command_node, attach_point)
                                ind = j
                            else:
                                arg_type = cmd_arg_type_check(child.word, arg_status)
                                # recurse to main normalization to handle argument
                                # with deep structures
                                normalize(child, attach_point, "argument", arg_type)
                            attach_point_info = look_above(attach_point)

            elif child.kind == "assignment":
                normalize(child, attach_point, "assignment")
            elif child.kind == "redirect":
                normalize(child, attach_point, "redirect")

            ind += 1

        # TODO: some commands get parsed with no head command
        # This is usually due to unrecognized utilities e.g. "mp3player".
        if len(utilities) == 0:
            return

        if len(utilities) > 1:
            print("Error: multiple utilitys in one command.")
            for u in utilities:
                print(u.value)
            sys.exit()

        head_command = utilities[0]

        # process (embedded) parenthese -- treat as implicit "-and"
        stack = []
        depth = 0

        def pop_stack_content(depth, rparenth, stack_top=None):
            # popping pushed states off the stack
            popped = stack.pop()
            while (popped.value != "("):
                head_command.remove_child(popped)
                popped = stack.pop()
            lparenth = popped
            if not rparenth:
                # unbalanced brackets
                rparenth = ArgumentNode(value=")")
                make_parent_child(stack_top.parent, rparenth)
                make_sibling(stack_top, rparenth)
            new_child = organize_buffer(lparenth, rparenth)
            i = head_command.substitute_parentheses(
                lparenth, rparenth, new_child)
            depth -= 1
            if depth > 0:
                # embedded parenthese
                stack.append(new_child)
            return depth, i

        i = 0
        while i < head_command.get_num_of_children():
            child = head_command.children[i]
            if child.value == "(":
                stack.append(child)
                depth += 1
            elif child.value == ")":
                assert(depth >= 0)
                # fix imbalanced parentheses: missing '('
                if depth == 0:
                    # simply drop the single ')'
                    detach_from_tree(child, child.parent)
                else:
                    depth, i = pop_stack_content(depth, child)
            else:
                if depth > 0:
                    stack.append(child)
                else:
                    if child.kind == "unarylogicop":
                        unprocessed_unary_logic_ops.append(child)
                    if child.kind == "binarylogicop":
                        unprocessed_binary_logic_ops.append(child)
            i += 1

        # fix imbalanced parentheses: missing ')'
        while (depth > 0):
            depth, _ = pop_stack_content(depth, None, stack[-1])

        assert(len(stack) == 0)
        assert(depth == 0)

        # for ul in unprocessed_unary_logic_ops:
        #     adjust_unary_operators(ul)

        # for bl in unprocessed_binary_logic_ops:
        #     adjust_binary_operators(bl)

        # recover omitted arguments
        if head_command.value == "find":
            arguments = []
            for child in head_command.children:
                if child.is_argument():
                    arguments.append(child)
            if head_command.get_num_of_children() > 0 and len(arguments) < 1:
                norm_node = ArgumentNode(value=".", arg_type="File")
                make_sibling(norm_node, head_command.children[0])
                norm_node.parent = head_command
                head_command.children.insert(0, norm_node)

        # "grep" normalization
        if head_command.value == "egrep":
            head_command.value = "grep"
            flag_present = False
            for child in head_command.children:
                if child.is_option() and child.value in ["-E", "--extended-regexp"]:
                    flag_present = True
            if not flag_present:
                norm_node = FlagNode(value="-E")
                make_sibling(norm_node, head_command.children[0])
                norm_node.parent = head_command
                head_command.children.insert(0, norm_node)

        if head_command.value == "fgrep":
            head_command.value = "grep"
            flag_present = False
            for child in head_command.children:
                if child.is_option() and child.value in ["-F", "--fixed-strings"]:
                    flag_present = True
            if not flag_present:
                norm_node = FlagNode(value="-F")
                make_sibling(norm_node, head_command.children[0])
                norm_node.parent = head_command
                head_command.children.insert(0, norm_node)

        # "xargs" normalization
        has_repl_str = False
        if head_command.value == "xargs":
            for flag in head_command.get_flags():
                if flag.value == "-I":
                    has_repl_str = True
                    repl_str = flag.get_argument()
                    assert(repl_str is not None)
                    if repl_str.value != "{}":
                        utility = head_command.get_subcommand()
                        assert(utility is not None)
                        utility.normalize_repl_str(repl_str.value, '{}')
                        repl_str.value = "{}"
                        repl_str.arg_type = "ReservedWord"
            # add a replace str if not present
            utility = head_command.get_subcommand()
            if not has_repl_str and utility is not None:
                for i in xrange(head_command.get_num_of_children()):
                    if head_command.children[i].is_utility():
                        repl_str_flag_node = FlagNode("-I")
                        repl_str_node = ArgumentNode("{}", "ReservedWord")
                        repl_str_node2 = ArgumentNode("{}", "ReservedWord")

                        head_command.children.insert(i, repl_str_flag_node)
                        repl_str_flag_node.parent = head_command
                        repl_str_flag_node.lsb = head_command.children[i-1]
                        head_command.children[i-1].rsb = repl_str_flag_node

                        make_parent_child(repl_str_flag_node, repl_str_node)
                        sub_command = head_command.children[i+1]
                        repl_str_node2.parent = sub_command
                        repl_str_node2.lsb = sub_command.get_right_child()
                        sub_command.children.append(repl_str_node2)
                        break

    def normalize(node, current, node_kind="", arg_type=""):
        # recursively normalize each subtree
        if not type(node) is bast.node:
            raise ValueError('type(node) is not ast.node')
        if node.kind == 'word':
            # assign fine-grained types
            if node.parts:
                # Compound arguments
                # commandsubstitution, processsubstitution, parameter
                if node.parts[0].kind == "processsubstitution":
                    if '>' in node.word:
                        norm_node = ProcessSubstitutionNode('>')
                        attach_to_tree(norm_node, current)
                        for child in node.parts:
                            normalize(child, norm_node)
                    elif '<' in node.word:
                        norm_node = ProcessSubstitutionNode('<')
                        attach_to_tree(norm_node, current)
                        for child in node.parts:
                            normalize(child, norm_node)
                elif node.parts[0].kind == "commandsubstitution":
                    norm_node = CommandSubstitutionNode()
                    attach_to_tree(norm_node, current)
                    for child in node.parts:
                        normalize(child, norm_node)
                elif node.parts[0].kind == "parameter" or \
                    node.parts[0].kind == "tilde":
                    normalize_argument(node, current, arg_type)
                else:
                    for child in node.parts:
                        normalize(child, current)
            else:
                normalize_argument(node, current, arg_type)
        elif node.kind == "pipeline":
            norm_node = PipelineNode()
            attach_to_tree(norm_node, current)
            # if len(node.parts) % 2 == 0:
            #     print("Error: pipeline node must have odd number of parts (%d)"
            #           % len(node.parts))
            #     print(node)
            #     sys.exit()
            for child in node.parts:
                if child.kind == "command":
                    normalize(child, norm_node)
                elif child.kind == "pipe":
                    pass
                else:
                    raise ValueError(
                        "Error: unrecognized type of child of pipeline node")
        elif node.kind == "list":
            if len(node.parts) > 2:
                # multiple commands, not supported
                raise ValueError("Unsupported: list of length >= 2")
            else:
                normalize(node.parts[0], current)
        elif node.kind == "commandsubstitution" or \
             node.kind == "processsubstitution":
            normalize(node.command, current)
        elif node.kind == "command":
            try:
                normalize_command(node, current)
            except AssertionError:
                raise AssertionError("normalized_command AssertionError")
        elif hasattr(node, 'parts'):
            for child in node.parts:
                # skip current node
                normalize(child, current)
        elif node.kind == "redirect":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "operator":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "parameter":
            # not supported
            raise ValueError("Unsupported: parameters")
        elif node.kind == "compound":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "list":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "for":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "if":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "while":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "until":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "assignment":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "function":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "tilde":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)
        elif node.kind == "heredoc":
            # not supported
            raise ValueError("Unsupported: %s" % node.kind)

    try:
        cmd2 = cmd.encode('utf-8')
    except UnicodeDecodeError:
        cmd2 = cmd

    try:
        tree = bparser.parse(cmd)
    except tokenizer.MatchedPairError:
        print("Cannot parse: %s - MatchedPairError" % cmd2)
        return None
    except errors.ParsingError:
        print("Cannot parse: %s - ParsingError" % cmd2)
        return None
    except NotImplementedError:
        print("Cannot parse: %s - NotImplementedError" % cmd2)
        return None
    except IndexError:
        print("Cannot parse: %s - IndexError" % cmd2)
        # empty command
        return None
    except AttributeError:
        print("Cannot parse: %s - AttributeError" % cmd2)
        # not a bash command
        return None
    except AssertionError:
        print("Cannot parse: %s - AssertionError" % cmd2)
        # not a bash command
        return None
    except TypeError:
        print("Cannot parse: %s - AssertionError" % cmd2)
        return None

    if len(tree) > 1:
        print("Doesn't support command with multiple root nodes: %s" % cmd2)
    normalized_tree = Node(kind="root")
    try:
        normalize(tree[0], normalized_tree)
    except ValueError as err:
        print("%s - %s" % (err.args[0], cmd2))
        return None
    except AttributeError as err:
        print("%s - %s" % (err.args[0], cmd2))
        return None
    except AssertionError as err:
        print("%s - %s" % (err.args[0], cmd2))
        return None

    if len(normalized_tree.children) == 0:
        # parsing not successful is there is only the root node in the tree
        return None

    return normalized_tree


def arg_slots(node):
    """Return argument slots of the ast."""
    slots = []

    def arg_slot_fun(node):
        if node.is_argument():
            slots.append([node.parent.value, node, False])
        else:
            for child in node.children:
                arg_slot_fun(child)

    arg_slot_fun(node)

    return [[node, taken] for _, node, taken in
            sorted(slots, key=lambda x:x[0])]


def prune_ast(node):
    """Return an ast without the argument nodes."""
    def prune_ast_fun(node):
        to_remove = []
        for child in node.children:
            if child.is_argument() and child.is_open_vocab():
                if child.lsb:
                    child.lsb.rsb = child.rsb
                if child.rsb:
                    child.rsb.lsb = child.lsb
                to_remove.append(child)
            else:
                prune_ast_fun(child)
        for child in to_remove:
            node.remove_child(child)

    if not node:
        return None
    node = copy.deepcopy(node)
    prune_ast_fun(node)

    return node


def order_ast(node):
    """Return an ast with sorted argument nodes."""
    def order_ast_fun(node):
        for child in node.chidren:
            pass
    if not node:
        return None
    node = copy.deepcopy(node)
    order_ast_fun(node)

    return node


def list_to_ast(list, order='dfs'):
    root = Node(kind="root", value="root")
    current = root
    if order == 'dfs':
        arg_status_stack = []
        for i in xrange(1, len(list)):
            if not current:
                break
            symbol = list[i]
            if symbol in [_V_NO_EXPAND, _H_NO_EXPAND]:
                if current and current.is_utility():
                    arg_status_stack.pop()
                current = current.parent
            else:
                kind, value = symbol.split('_', 1)
                kind = kind.lower()
                # add argument types
                if kind == "argument":
                    if current.is_option():
                        head_cmd = current.utility.value
                        flag = current.value
                        arg_type = \
                            man_lookup.get_flag_arg_type(head_cmd, flag)
                    elif current.is_utility():
                        arg_type = cmd_arg_type_check(
                            value, arg_status_stack[-1])
                    else:
                        print("Warning: to_ast unrecognized argument "
                              "attachment point {}.".format(current.symbol))
                        arg_type = "Unknown"
                    if value in ["+", ";", "{}"]:
                        arg_type = "ReservedWord"
                    node = ArgumentNode(value=value, arg_type=arg_type)
                elif kind == "flag":
                    node = FlagNode(value=value)
                elif kind == "utility":
                    node = UtilityNode(value=value)
                    arg_status = copy.deepcopy(
                            man_lookup.get_arg_types(value))
                    arg_status_stack.append(arg_status)
                elif kind == "unarylogicop":
                    node = UnaryLogicOpNode(value=value)
                else:
                    node = Node(kind=kind, value=value)
                attach_to_tree(node, current)
                current = node
    else:
        raise NotImplementedError
    return root


def to_command(node, loose_constraints=False, ignore_flag_order=False):
    if not node:
        return ''

    lc = loose_constraints
    ifo = ignore_flag_order

    def to_command_fun(node):
        str = ''
        if node.is_root():
            assert(loose_constraints or node.get_num_of_children() == 1)
            if lc:
                for child in node.children:
                    str += to_command_fun(child)
            else:
                str += to_command_fun(node.get_left_child())
        elif node.kind == 'pipeline':
            assert(loose_constraints or node.get_num_of_children() > 1)
            if lc and node.get_num_of_children() < 1:
                str += ''
            elif lc and node.get_num_of_children() == 1:
                str += to_command_fun(node.get_left_child())
            else:
                for child in node.children[:-1]:
                    str += to_command_fun(child)
                    str += ' | '
                str += to_command_fun(node.get_right_child())
        elif node.kind == "commandsubstitution":
            assert(loose_constraints or node.get_num_of_children() == 1)
            if lc and node.get_num_of_children() < 1:
                str += ''
            else:
                str += '$('
                str += to_command_fun(node.get_left_child())
                str += ')'
        elif node.kind == 'processsubstitution':
            assert(loose_constraints or node.get_num_of_children() == 1)
            if lc and node.get_num_of_children() < 1:
                str += ''
            else:
                str += '{}('.format(node.value)
                str += to_command_fun(node.get_left_child())
                str += ')'
        elif node.is_utility():
            str += node.value + ' '
            children = sorted(node.children, key=lambda x:x.value) \
                if ifo else node.children
            for child in children:
                str += to_command_fun(child) + ' '
            str = str.strip()
        elif node.is_option():
            assert(loose_constraints or node.parent)
            if '::' in node.value:
                value, op = node.value.split('::')
                str += value + ' '
            else:
                arg_connector = '=' if (node.is_long_option() and
                                        node.children) else ' '
                str += node.value + arg_connector
            for child in node.children:
                str += to_command_fun(child) + ' '
            if '::' in node.value:
                if op == ';':
                    op = "\\;"
                str += op + ' '
            str = str.strip()
        elif node.kind == "binarylogicop":
            assert(loose_constraints or node.get_num_of_children() == 0)
            if lc and node.get_num_of_children() > 0:
                for child in node.children[:-1]:
                    str += to_command_fun(child) + ' '
                    str += node.value + ' '
                str += to_command_fun(node.children[-1])
                str = str.strip()
            else:
                str += node.value
        elif node.kind == "unarylogicop":
            assert(loose_constraints or node.get_num_of_children() == 0)
            if lc and node.get_num_of_children() > 0:
                if node.associate == UnaryLogicOpNode.RIGHT:
                    str += '{} {}'.format(
                        node.value, to_command_fun(node.get_left_child()))
                else:
                    str += '{} {}'.format(
                        to_command_fun(node.get_left_child()), node.value)
            else:
                str += node.value
        elif node.kind == "bracket":
            assert(loose_constraints or node.get_num_of_children() >= 1)
            if lc and node.get_num_of_children() < 2:
                for child in node.children:
                    str += to_command_fun(child) 
            else:
                str += "\\( "
                for i in xrange(len(node.children)):
                    str += to_command_fun(node.children[i]) + ' '
                str += "\\)"
        elif node.is_argument():
            assert(loose_constraints or node.get_num_of_children() == 0)
            str += node.value
            if lc:
                for child in node.children:
                    str += to_command_fun(child)
        return str

    return to_command_fun(node)
