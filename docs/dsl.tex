%!TEX root=writeup.tex
\subsection{Bash Syntax and Manpage Extraction}
\label{subsec:represent}

The core Bash syntax (\autoref{fig:bash-syntax}) is very simple, but every tool imposes its own constraints on top of this. For instance, \<-c> is not a valid flag for the \<mv> tool. The translation task is much easier if these additional constraints are available at translation time. Fortunately, in this domain they do not need to be hand-coded; publicly-available manpages already document the acceptable ways to call each tool.

\begin{figure}[ht]
\begin{align*}
\mathit{bash} \quad :=& \quad \mathit{cmd} ~\mid~ \mathit{bash}|\mathit{cmd} \\
\mathit{cmd}  \quad :=& \quad \mathit{word}~(~\mathit{word}~)^{*}
\end{align*}
\vspace{-20pt}
\caption{Core bash syntax}
\label{fig:bash-syntax}
\end{figure}

%%% This paragraph is a good point, but probably not one we need to make here.
%%%   -- Calvin
% The key design tradeoff for the language is the level of declarativity. The more declarative the langauge is, it is easier to perform translation, e.g. if \code{max} is provided as a primitive of the language, it is possible to direct translate descriptions with notion of maxinum into a command using the primitive \code{max}, on the other hand, if it is not provided, the command should be achieved using \code{sort} following by \code{first} to acheive the same goal, which is less straightforward compared to the first case. However, when the language is too declarative, collecting training data are harder, as it is harder to transform real bash commands in the dataset to its intermediate representation. In our design, we choose the latter case, to make the language designed to be closer to the original bash commands, so that we can directly parse a bash command into its intermediate representation, which provides us a larger set of traning data. \autoref{fig:lang} presents the syntax of the intermediate language.

\autoref{fig:grammars} shows the kind of syntax we are able to infer from
manpages, and \autoref{fig:manpage-extraction} shows an example extraction for
the \<sort> manpage. The extracted grammars simply substitute for \|cmd| in the
overall grammar from \autoref{fig:bash-syntax}.

The extracted grammars have a very structured form. The empty string $\epsilon$
is usually used in conjunction with the cases construct to describe optional
flags, as in the case of $(\epsilon \mid \text{``-s''})$. Exact strings usually
represent flags such as \<-v> or \<-r>. The Arg form indicates that an arbitrary
string may be used; these are placeholders for arguments, such as the filename
arguments to \<rm> or \<mv>. Type information (while not used in the current
system) is generally present and may improve future iterations of our tool.
Finally, the sequence construct can chain together sequential pieces of a
grammar. Notably, we always infer a strict order among the flags for a given
command. This further restricts our output space, yielding increased performance
without impairing expressiveness.

\begin{figure}[h]
    \begin{center}
    \begin{minipage}[t]{0.4\linewidth}
        \[\begin{array}{rrll}
        G   & :=   & \epsilon                & \text{(Empty string)} \\
            & \mid & \text{``\|word|''}      & \text{(Exact string)} \\
            & \mid & \text{Arg} ~ \|type|    & \text{(Argument)} \\
            & \mid & G_1 ~ G_2 ~ ...         & \text{(Sequence)} \\
            & \mid & G_1 \mid G_2 \mid ...   & \text{(Cases)} \\
        \end{array}\]
    \end{minipage}
    \begin{minipage}[t]{0.5\linewidth}
        \[\begin{array}{rrl}
        \|type| & :=   & \text{File}
                  \mid   \text{Number}
                  \mid   \text{Pattern}
                  \mid   \text{PermissionMode} \\
                & \mid & \text{Size}
                  \mid   \text{Username}
                  \mid   \text{Groupname}
                  \mid   \text{Unknown}
        \end{array}\]
    \end{minipage}
    \end{center}
    \caption{Syntax of grammars extracted from manpages.}
    \label{fig:grammars}
\end{figure}

%%% This figure is glorious, but it is not reflective of the tool we actually
%%% built.
%%%   -- Calvin
% \begin{figure}[ht]
% \[
% \begin{array}{rlll}
% \multicolumn{3}{l}{\textbf{Program}}\\
% \mathit{p} & :=  & \mathit{cmd}~\overline{\mathit{option}} & \textrm{(Program)}\\
%     &  & \mathit{p} ~|~ \mathit{p} & \textrm{(Pipelined programs)} \\
% \mathit{option} & := & \mathit{flag} & \textrm{(Command flag)}\\
%                 &    & \mathit{val} & \textrm{(Value)}\\
% \mathit{cmd} & := & ... & \textrm{(Command names)}\\
% \mathit{flag} & := & ... & \textrm{(Flag names)}\\
% \mathit{val} & := & ...  & \textrm{(Primitive values)}\\
% ~\\
% \multicolumn{3}{l}{\textbf{Command Signature}}\\
% \mathit{sig} & := & \mathit{name}~\mathit{op} & \textrm{(Command signature)}\\
% \mathit{op} &:= & \mathit{flag} & \textrm{(Flag)}\\
%                 &   & \mathit{arg}:\tau & \textrm{(Argument)}\\
%                 &   & \mathit{arg}:\tau~...& \textrm{(Argument list)}\\
%                 &   & \mathit{op}~\mathit{op} & \textrm{(Sequential options)}\\
%                 &   & \mathit{op}~|~\mathit{op} & \textrm{(Exclusive options)}\\
%                 &   & [ \mathit{op} ] & \textrm{(Optional options)}\\
% ~\\
% \multicolumn{3}{l}{\textbf{Rules}}\\
% \mathit{rule}^{*} &:=& \mathit{cmd}~\overline{\mathit{option}} : \tau & \textrm{(Command typing rule)}\\
% ~\\
% \multicolumn{3}{l}{\textbf{Types}}\\
% \tau_0 & := & \mathsf{void},~ \mathsf{File},~ \mathsf{Date},~\mathsf{Perm} ...& \textrm{(Primitive types)}\\
% \tau & := & \tau_0 ~|~ (\bar{\tau}_0)\rightarrow \tau_0 & \textrm{(Type)}
% \end{array}
% \]
% \caption{Intermediate Language syntax, where $\mathit{cmd}$ ranges over strings presernting command names, $\mathit{flag}$ are strings presenting flag names, $\mathit{val}$ presents values in bash programs, and $\mathit{arg}$ represents meta-argument names.}
% \label{fig:lang}
% \end{figure}

% In the intermediate language, \textit{Program} defines the formation rules for a command: i.e. a command is either a primitive command or the pipeline of two programs. However, not every programs that can be represented by the syntax is valid, e.g. the program \code{find -goal} is well formed under the syntax, but it is not a valid real CLI program, as the \code{goal} flag is not part of the command \code{find}. Thus, \textit{command signatures} are introduced to check the well-formedness of a given bash command.

% \textit{Command signature} in \autoref{fig:lang} defines the usages for certain commands: a command is well formed only if it follows its corresponding structure. \textit{types} reflect the type of an argument, helping restrict usage of values in a command as types used in other typed languages. Figure~\ref{fig:cmdsig} shows the signature of some commands used in our system. With this signature, the command \code{mv -f -v a.txt b.txt} is will formed as it is captured by the signature of \code{mv}.

\begin{figure}
    \begin{center}
    \begin{minipage}[t]{0.6\linewidth}
        \textbf{Manpage:} \\
        \begin{lstlisting}[gobble=8]
        ...

        SYNOPSIS
            sort [-bdfgiMnrckmosStTuz] [file ...]

        DESCRIPTION
            ...

            -s, --stable
                   stabilize sort by disabling last-resort comparison

            -S, --buffer-size=SIZE
                   use SIZE for main memory buffer

            ...
        \end{lstlisting}
    \end{minipage}
    \begin{minipage}[t]{0.39\linewidth}
        \textbf{Extracted grammar:} \\
        \begin{align*}
            \text{``sort''} ~ ~ & ... \\
                & (\epsilon \mid \text{``-s''}) \\
                & (\epsilon \mid (\text{``-S''} ~ (\text{Arg Size}))) \\
                & ... \\
                & (\epsilon \mid (\text{Arg File}))
        \end{align*}
    \end{minipage}
    \end{center}

    \caption{Sample grammar extraction for \<sort> using the grammar syntax
        from \autoref{fig:grammars}.}
    \label{fig:manpage-extraction}
\end{figure}

Our manpage extraction looks at the \<SNYPOSIS> section of the manpage to obtain
the legal list of flags as well as the names and types of positional arguments.
The \<DESCRIPTION> section describes each flag in more detail, and from this we
obtain information about arguments to flags and their types.

Unfortunately, this process is semi-automated instead of fully automated, due to
the fact that many commands include constraints that are not represented in the
manpage in a machine-readable manner. For example, the man page of ``find'' uses
the non-terminal ``expression'' in its grammar in the \<SYNOPSIS> section, and
describes in text that readers should refer to the \<PRIMARIES> section to learn
how ``expression'' is expanded into terminals. As a result, we first parse the
synopsis and then manually clean them before feeding to the system. The only
command requiring a great deal of cleaning work is ``find''.
