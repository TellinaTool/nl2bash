%!TEX root=writeup.tex
\section{Introduction}

% What is the problem?
% Why is it important?
% What makes it hard?
% How will we solve it?

The command line interface (CLI) enables users to perform a rich set of actions including file system manipulation, system configuration, batch processing, and more. CLI programming is considered an important software development skill; many companies expect CLI proficiency when hiring new software engineers. CLI programming also greatly boosts productivity in other professions, including research science, medicine, and education. Professionals in these fields often have experimental results and other relevant information stored on hard disks, and need to repeatedly perform file operations to retrieve and update that information. Most of these operations can be succinctly represented as short CLI programs.

Unfortunately, the rich vocabulary available to CLI users requires a high degree of memorization and familiarity. As a result, new users often find it difficult to master, and even experienced CLI programmers often forget the exact options necessary to implement their intents. On the other hand, common tasks user performed can be expressed  succinctly in natural language~\cite{Myers:2004:NPL:1015864.1015888}, and
these natural language specifications are precise enough that expert users can
usually produce correct solutions---or at least, solutions requiring minimal
adjustment. The table below shows a few examples of natural language
descriptions paired up with executable command line programs. The examples are gathered from
StackOverflow, UnixExchange, and other online sources.

\begin{center}
% \begin{table}[ht]
\begin{tabular}{p{3in}p{3in}}
    \textbf{Question} & \textbf{Answer} \\
    \hline \hline
    How to count all the lines of code in a directory recursively?%
        \footnote{\url{https://stackoverflow.com/questions/1358540/how-to-count-all-the-lines-of-code-in-a-directory-recursively}} &
        \texttt{find . -name `*.php' | xargs wc -l} \\
    \hline
    Copy folder recursively, excluding some folders%
        \footnote{\url{https://stackoverflow.com/questions/2193584/copy-folder-recursively-excluding-some-folders}} &
        \texttt{rsync -av --exclude='path1/to/exclude' --exclude='path2/to/exclude' source destination} \\
     \hline
     Find the 100 biggest files on your system%
         \footnote{\url{http://pro-toolz.net/data/programming/bash/important_shell_commands.html}}&
         \texttt{find / -type f -ls | awk `\{print \$7,\$11\}' | sort -n | tail -100} \\
     \hline
     Find the most recently modified files in a directory and all subdirectories%
         \footnote{\url{http://www.bashoneliners.com/oneliners/oneliner/80/}}&
         \texttt{find /path/to/dir -type f -mtime -7 -print0 | xargs -0 ls -lt | head} \\
\end{tabular}
% \caption{Natural language description and command line pairs crawled from StackOverflow.}
% \end{table}
\end{center}

% Online forums such as StackOverflow\footnote{\url{https://stackoverflow.com}}, UnixExchange\footnote{\url{http://unix.stackexchange.com/questions/tagged/bash}} and BashOneLiner\footnote{\url{http://www.bashoneliners.com/oneliners/oneliner/popular/}} provide a large set of simple questions and proposed solutions. For example:

Thus, there is great value in automatically converting natural language commands into CLI programs~\cite{Pedersen-Report,zoltan1991get,Manaris:1994:DNL:198125.198137}.
Given natural language descriptions of a task (such as those on the left), we desire a system to automatically translate them into executable commands (such as those on the right).
% Natural language programming techniques
Natural language specifications have seen success in several domains, including database queries~\cite{DBLP:journals/pvldb/LiJ14, DBLP:conf/sigmod/GulwaniM14}, text editing~\cite{DBLP:journals/corr/DesaiGHJKMRR15} and smart phone scripting~\cite{DBLP:conf/mobisys/LeGS13}.
There are a few factors that make command line operations challenging, specifically:
\begin{itemize}
\item \textbf{Ambiguity in natural language.} Natural language descriptions are inherently ambiguous. Although techniques such as keyword-based translation~\cite{DBLP:conf/sigmod/GulwaniM14}, semantic parsing~\citep{Zettlemoyer05learningto}, and interactive disambiguation~\cite{DBLP:journals/pvldb/LiJ14} have been proposed, state-of-the-art natural language processing approaches are still error prone and cover limited set of linguistic phenomena.
% there are still no general techniques that can handle all inputs.
Unfortunately, partial and ill-formed descriptions are common in command line questions. It can be seen from the examples above that users tend to omit many details such as the names of the directories, which seems natural to skip in conversations but are in fact essential to program synthesis. In the last two examples shown above, the system needs to figure out that ``biggest'' makes the operations of sorting the files based on the size attribute and ``most recently'' requires filtering the files based on the modification time. Both operations are related to the lexical meanings of the words different ways.

\item \textbf{Richness in basic operations.} Different from domains such as database queries, which are complex in their program structure but simple in the atomic operations, command line programs are often simple in structure but complex in basic operations. The large set of basic operations are informally described informally in man pages, and as a result, the synthesizer designer will need to manually write down the formal specification to build a synthesizer. (We consider this a problem that will be solved in the project, but we exclude it from the course project submission due to timing issues.)
\end{itemize}

In the next session we briefly describe our approach to the system design.
