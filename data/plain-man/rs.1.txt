
RS(1)                     BSD General Commands Manual                    RS(1)

NAME
     rs -- reshape a data array

SYNOPSIS
     rs [-[csCS][x] [kKgGw][N] tTeEnyjhHmz] [rows [cols]]

DESCRIPTION
     The rs utility reads the standard input, interpreting each line as a row
     of blank-separated entries in an array, transforms the array according to
     the options, and writes it on the standard output.  With no arguments it
     transforms stream input into a columnar format convenient for terminal
     viewing.

     The shape of the input array is deduced from the number of lines and the
     number of columns on the first line.  If that shape is inconvenient, a
     more useful one might be obtained by skipping some of the input with the
     -k option.  Other options control interpretation of the input columns.

     The shape of the output array is influenced by the rows and cols specifi-
     cations, which should be positive integers.  If only one of them is a
     positive integer, rs computes a value for the other which will accommo-
     date all of the data.  When necessary, missing data are supplied in a
     manner specified by the options and surplus data are deleted.  There are
     options to control presentation of the output columns, including transpo-
     sition of the rows and columns.

     The following options are available:

     -cx     Input columns are delimited by the single character x.  A missing
             x is taken to be `^I'.

     -sx     Like -c, but maximal strings of x are delimiters.

     -Cx     Output columns are delimited by the single character x.  A miss-
             ing x is taken to be `^I'.

     -Sx     Like -C, but padded strings of x are delimiters.

     -t      Fill in the rows of the output array using the columns of the
             input array, that is, transpose the input while honoring any rows
             and cols specifications.

     -T      Print the pure transpose of the input, ignoring any rows or cols
             specification.

     -kN     Ignore the first N lines of input.

     -KN     Like -k, but print the ignored lines.

     -gN     The gutter width (inter-column space), normally 2, is taken to be
             N.

     -GN     The gutter width has N percent of the maximum column width added
             to it.

     -e      Consider each line of input as an array entry.

     -n      On lines having fewer entries than the first line, use null
             entries to pad out the line.  Normally, missing entries are taken
             from the next line of input.

     -y      If there are too few entries to make up the output dimensions,
             pad the output by recycling the input from the beginning.  Nor-
             mally, the output is padded with blanks.

     -h      Print the shape of the input array and do nothing else.  The
             shape is just the number of lines and the number of entries on
             the first line.

     -H      Like -h, but also print the length of each line.

     -j      Right adjust entries within columns.

     -wN     The width of the display, normally 80, is taken to be the posi-
             tive integer N.

     -m      Do not trim excess delimiters from the ends of the output array.

     -z      Adapt column widths to fit the largest entries appearing in them.

     With no arguments, rs transposes its input, and assumes one array entry
     per input line unless the first non-ignored line is longer than the dis-
     play width.  Option letters which take numerical arguments interpret a
     missing number as zero unless otherwise indicated.

EXAMPLES
     The rs utility can be used as a filter to convert the stream output of
     certain programs (e.g., spell(1), du(1), file(1), look(1), nm(1), who(1),
     and wc(1)) into a convenient ``window'' format, as in

           % who | rs

     This function has been incorporated into the ls(1) program, though for
     most programs with similar output rs suffices.

     To convert stream input into vector output and back again, use

           % rs 1 0 | rs 0 1

     A 10 by 10 array of random numbers from 1 to 100 and its transpose can be
     generated with

           % jot -r 100 | rs 10 10 | tee array | rs -T > tarray

     In the editor vi(1), a file consisting of a multi-line vector with 9 ele-
     ments per line can undergo insertions and deletions, and then be neatly
     reshaped into 9 columns with

           :1,$!rs 0 9

     Finally, to sort a database by the first line of each 4-line field, try

           % rs -eC 0 4 | sort | rs -c 0 1

SEE ALSO
     jot(1), pr(1), sort(1), vi(1)

BUGS
     Handles only two dimensional arrays.

     The algorithm currently reads the whole file into memory, so files that
     do not fit in memory will not be reshaped.

     Fields cannot be defined yet on character positions.

     Re-ordering of columns is not yet possible.

     There are too many options.

     Multibyte characters are not recognized.

BSD                              July 30, 2004                             BSD
